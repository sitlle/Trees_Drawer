        -:    0:Source:/home/yeawer/tree/AVL.h
        -:    0:Graph:/home/yeawer/tree/cmake-build-debug-coverage/CMakeFiles/tree.dir/FrontEnd.cpp.gcno
        -:    0:Data:/home/yeawer/tree/cmake-build-debug-coverage/CMakeFiles/tree.dir/FrontEnd.cpp.gcda
        -:    0:Runs:1
        -:    1:#include<bits/stdc++.h>
        -:    2:#include"Random.h"
        -:    3:#include"Node_AVL.h"
        -:    4:#pragma once
        -:    5:class AVL {
        -:    6:public:
        -:    7:    Node_AVL* root;
function _ZN3AVLC2Ev called 1 returned 100% blocks executed 100%
        1:    8:    AVL() {
        1:    9:        root = nullptr;
        1:   10:    }
        -:   11:
        -:   12:    ~AVL() = default;
        -:   13:
        -:   14:    AVL(AVL const& other) {
        -:   15:        root = other.root;
        -:   16:    }
        -:   17:
        -:   18:    void Add_X(int32_t counter) {
        -:   19:        for (int32_t i = 0; i < counter; ++i) {
        -:   20:            int64_t num = get_random() % 100;
        -:   21:            Add(num);
        -:   22:        }
        -:   23:    }
        -:   24:
        -:   25:    void Add(int64_t val) {
        -:   26:        if (root == nullptr) {
        -:   27:            root = new Node_AVL(val);
        -:   28:            return;
        -:   29:        }
        -:   30:        root = Global_Balanced(root, val);
        -:   31:    }
        -:   32:
        -:   33:    bool Find(int32_t val) {
        -:   34:        return Find(root, val);
        -:   35:    }
        -:   36:
        -:   37:    void Print() {
        -:   38:        Print(root);
        -:   39:    }
        -:   40:
        -:   41:private:
        -:   42:    void clear(Node_AVL* vertex) {
        -:   43:        if (vertex == nullptr) {
        -:   44:            return;
        -:   45:        }
        -:   46:        clear(vertex->left);
        -:   47:        clear(vertex->right);
        -:   48:        delete[] vertex;
        -:   49:    }
        -:   50:
        -:   51:    void Print(Node_AVL* vertex) {
        -:   52:        if (vertex == nullptr) {
        -:   53:            return;
        -:   54:        }
        -:   55:        Print(vertex->left);
        -:   56:        std::cout << vertex->val << ' ';
        -:   57:        Print(vertex->right);
        -:   58:    }
        -:   59:
        -:   60:    bool Find(Node_AVL* vertex, int64_t val) {
        -:   61:        if (vertex == nullptr) {
        -:   62:            return false;
        -:   63:        }
        -:   64:        if (vertex->val == val) {
        -:   65:            return true;
        -:   66:        }
        -:   67:        if (val < vertex->val) {
        -:   68:            return Find(vertex->left, val);
        -:   69:        } else {
        -:   70:            return Find(vertex->right, val);
        -:   71:        }
        -:   72:    }
        -:   73:
        -:   74:    int32_t get_height(const Node_AVL* vertex) {
        -:   75:        if (vertex == nullptr) {
        -:   76:            return 0;
        -:   77:        }
        -:   78:        return vertex->height;
        -:   79:    }
        -:   80:
        -:   81:    int32_t get_balance(const Node_AVL* vertex) {
        -:   82:        if (vertex == nullptr) {
        -:   83:            return 0;
        -:   84:        }
        -:   85:        return get_height(vertex->right) - get_height(vertex->left);
        -:   86:    }
        -:   87:
        -:   88:    void Update(Node_AVL* vertex) {
        -:   89:        vertex->height = std::max(get_height(vertex->left),
        -:   90:                                  get_height(vertex->right)) + 1;
        -:   91:        vertex->balance = get_balance(vertex);
        -:   92:    }
        -:   93:
        -:   94:    Node_AVL* L_Rotate(Node_AVL* vertex) {
        -:   95:        Node_AVL* right_child = vertex->right;
        -:   96:        vertex->right = right_child->left;
        -:   97:        right_child->left = vertex;
        -:   98:        Update(vertex);
        -:   99:        Update(right_child);
        -:  100:        return right_child;
        -:  101:    }
        -:  102:
        -:  103:    Node_AVL* R_Rotate(Node_AVL* vertex) {
        -:  104:        Node_AVL* left_child = vertex->left;
        -:  105:        vertex->left = left_child->right;
        -:  106:        left_child->right = vertex;
        -:  107:        Update(vertex);
        -:  108:        Update(left_child);
        -:  109:        return left_child;
        -:  110:    }
        -:  111:
        -:  112:    Node_AVL* Local_Balanced(Node_AVL* vertex) {
        -:  113:        Update(vertex);
        -:  114:        if (get_balance(vertex) == 2) {
        -:  115:            if (get_balance(vertex->right) < 0) {
        -:  116:                vertex->right = R_Rotate(vertex->right);
        -:  117:            }
        -:  118:            return L_Rotate(vertex);
        -:  119:        }
        -:  120:        if (get_balance(vertex) == -2) {
        -:  121:            if (get_balance(vertex->left) > 0) {
        -:  122:                vertex->left = L_Rotate(vertex->left);
        -:  123:            }
        -:  124:            return R_Rotate(vertex);
        -:  125:        }
        -:  126:        return vertex;
        -:  127:    }
        -:  128:
        -:  129:    Node_AVL* Global_Balanced(Node_AVL* vertex, int64_t& val) {
        -:  130:        if (val <= vertex->val) {
        -:  131:            if (vertex->left != nullptr) {
        -:  132:                vertex->left = Global_Balanced(vertex->left, val);
        -:  133:            } else {
        -:  134:                auto new_node = new Node_AVL(val, 0);
        -:  135:                vertex->left = new_node;
        -:  136:                Update(vertex);
        -:  137:                return vertex;
        -:  138:            }
        -:  139:        } else {
        -:  140:            if (vertex->right != nullptr) {
        -:  141:                vertex->right = Global_Balanced(vertex->right, val);
        -:  142:            } else {
        -:  143:                auto new_node = new Node_AVL(val, 0);
        -:  144:                vertex->right = new_node;
        -:  145:                Update(vertex);
        -:  146:                return vertex;
        -:  147:            }
        -:  148:        }
        -:  149:        return Local_Balanced(vertex);
        -:  150:    }
        -:  151:};
